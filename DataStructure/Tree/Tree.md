# Tree

### tree의 개념

노드로 이루어진 자료구조

1. 하나의 루트 노드를 갖는다
2. 루트 노드는 0개 이상의  자식 노드를 갖고 있다
3. 자식 노드 또한 0개 이상의 자식 노드를 갖고 있다.

- 노드(node)들과 노드들을 연결하는 간선(edge)들로 구성

  - 사이클이 존재할 수 없다.
  - 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을 수도 있다.
  - 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수고 있다.
  - 각 노드는 어떤 자료형으로도 표현 가능하다.

  ```java
  class Node{
      public String name;
      public Node[] children;
  }
  ```

- 비선형 자료구조로 계층적 관계를 표현

- 그래프의 한종류

  - 사이클이 없는 하나의 연결 그래프
  - DAG(Directed Acyclic Graph, 방향성이 있는 비순환 그래프)의 한 종류

### tree와 관련된 용어

- 루트 노드(root node) : 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.

- 단말 노드(leaf node) : 자식이 없는 노드, '말단노드'/ '잎노드'

- 내부 노드(internal node) : 단말 노드가 아닌 노드

- 간선(edge) : 노드를 연결하는 선, 가지(branch)

- 형제(sibling) : 같은 부모를 가진 노드

- 노드의 크기(size) : 자신을 포함한 모든 자손 노드의 개수

- 노드의 깊이(depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수

- 노드의 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합

- 노드의 차수 (degree): 하위 트리 개수/간선 수 = 각 노드가 지닌 가지의 수

- 트리의 차수(degree of tree) : 트리의 최대 차수

- 트리의 높이(height) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이

  

### tree의 특징

- 그래프의 한 종류이다. '최소 연결 트리'라고도 불린다
- **계층 모델**
- DAG의 한 종류이다. loop도 circuit도 self-loop도 없다. 즉, 사이클이 없다.
- 노드가 n개인 트리는 항상 n-1개의 간선을 가진다.
- 임의의 두 노드 간의 경로는 유일하다. 즉, 두개의 정점 사이에 반드시 1개의 경로만 존재한다.
- 한 개의 루트 노드만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가진다. 흐름은 top-bottom 아니면 bottom-top으로 이루어진다.
- 순회는 전위, 중위, 후위 중 하나로 이루어진다. 모두 DFS/BFS 안에 있다.

### tree의 종류

- 이진 트리(Binary Tree)

  - 각 노드가 최대 두 개의 자식을 갖는 트리, 모든 노드의 차수가 2이하인 트리

  - 모든 트리가 이진 트리는 아니다.

  - 이진 트리 순회

    - 중위 순회(in-order traversal) : 왼쪽->현재->오른쪽

    - 전위 순회(pre-order traversal) : 현재->외쪽>오른쪽
    
    - 후위 순회(post-order traversal) : 왼쪽->오른쪽->현재
    
  
- 이진 탐색 트리(Binary Search Tree)

  - 모든 노드가 아래와 같은 특정 순서를 따른 속성이 있는 이진 트리
  - 모든 왼쪽 자식들 <= N < 모든 오른쪽 자식들(모든 노드 N에 대해서 반드시 참)

- 균형 트리 / 비균형 트리

  - 균형 트리: O(logn) 시간에 insert와 find를 할 수 있을 정도로 균형이 잘 잡혀 있는 경우

- 완전 이진 트리(Complete Tree)

  - 마지막 레벨을 제외한 트리의 모든 레벨이 완전히 채워져 있다.
  - 마지막 레벨은 차있지 않다면 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
  - 마지막 레벨 h에서 (1~2h-1)개의 노드를 가질 수 있다.
  - 가장 오른쪽의 잎 노드가 (아마도 모두) 제거된 포화 이진 트리
  - 배열을 사용해 효율적으로 표현 가능하다.

- 전 이진 트리(Full Binary Tree or Strictly Binary Tree)

  - 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

- 포화 이진 트리(Perfect Binary Tree)

  - 전 이진 트리면서 완전 이진 트리인 경우
  - 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.
  - 모든 내부 노드가 두 개의 자식 노드를 가진다.
  - 모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.
  - 노드의 개수가 정확히 2^(k-1)개 (k:트리의 높이)

- 이진 힙(최소힙과 최대힙)

  - 최소힙(Min Heap)
    - 트리의 마지막 단계에서 오른쪽 부분을 뺸 나머지 부분이 가즉 채워져 있는 완전 이진 트리, 각 노드의 원소가 자식들의 원소보다 작다.
      - 즉, key(부모노드)<key(자식 노드)인 완전 이진 트리
      - 가장 작은 값은 루트 노드
      - n개가 힙에 들어가 있으면 높이는 log(n)
  - 최대힙(Max Heap)
    - 원소가 내림차순으로 정렬되어 있다는 점에서만 최소힙과 다르다.
    - 각 노드의 원소가 자식들의 원소보다 크다.

- 트라이(trie) or 접두사 트리(Prefix Tree)

  - n-차 트리(n-ary Tree)의 변종
  - 각 노드에 문자를 저장하는 자료구조
  - 트리를 아래쪽으로 순회하면 단어 하나가 나온다
  - 접두사를 빠르게 찾아보기 위한 흔한 방식, 모든 언어를 트라이에 저장해 놓는 방식이 있다.
  - 유효한 단어 집합을 이용하는 많은 문제들은 트라이를 통해 최적화할 수 있다.

### tree의 구현 방법

기본적으로 트리는 그래프의 한 종류이므로 그래프의 구현방법(인접 리스트/인접 배열)으로 구현할 수 있다.

- 인접 배열 이용

  1. 1차원 배열에 자신의 부모 노드만 저장하는 방법
     - 트리는 부모 노드를 0개 또는 1개를 가지기 때문
     - 부모 노드 0개 : 루트노드
  2. 이진 트리의 경우, 2차원 배열에 자식 노드를 저장하는 방법
     - 각 노드가 최대 두 개의 자식을 갖는 트리이기 때문
     - ex) A[i] [0] : 왼쪽 자식 노드, A[i] [1]: 오른쪽 자식 노드

- 인접 리스트 이용

  1. 가중치가 없는 트리의 경우

     ArrayList&lt;ArrayList> list = new ArrayList<>();

  2. 가중치가 있는 트리의 경우

     class Node{ int num, dist; } //노드 번호, 거리

     ArrayList[] list = new ArrayList[정점의수 + 1];























